---
title: '[코딩테스트 풀기] 프로그래머스 lv3. 베스트앨범 (+시간복잡도)'
date: '2023-08-05'
category: 'algorithm'
summary: '해시 / 프로그래머스 lv3 베스트앨범 풀기'
---

베스트앨범
https://school.programmers.co.kr/learn/courses/30/lessons/42579

## 문제

스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다.

> 속한 노래가 많이 재생된 장르를 먼저 수록합니다.
> 장르 내에서 많이 재생된 노래를 먼저 수록합니다.
> 장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다.

노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요.

## 해결

1. 장르를 key값으로 가지는 object를 생성하여 자료를 정리한다.
2. 장르 별로 재생 횟수를 내림차순으로 정리한다.
3. 문제에서 제시한 순서대로 노래의 고유 번호를 빈 배열에 넣는다.

```js
function solution(genres, plays) {
  const genresMap = {};

  for (let i = 0; i < genres.length; i++) {
    const genre = genres[i];
    if (!genresMap[genre]) {
      genresMap[genre] = {
        score: 0,
        musics: [],
      };
    }
    genresMap[genre].score += plays[i];
    genresMap[genre].musics.push([i, plays[i]]);
    // index를 함께 저장하여야 나중에 앨범 수록 시, 고유번호를 넣을 수 있음
  }

  const sortedGenres = Object.keys(genresMap).sort(
    (a, b) => genresMap[b].score - genresMap[a].score
  );

  const answer = [];

  for (const genre of sortedGenres) {
    const musics = genresMap[genre].musics.sort((a, b) => {
      if (a[1] !== b[1]) {
        return b[1] - a[1];
      } else {
        return a[0] - b[0];
      }
    });

    const numToTake = Math.min(musics.length, 2);
    for (let i = 0; i < numToTake; i++) {
      answer.push(musics[i][0]);
    }
  }

  return answer;
}
```

## 시간복잡도

1. genresMap 객체 생성

- for문을 통해 genres와 plays 배열을 순회하며 객체에 값을 추가함
- 시간복잡도 O(n)

2. 장르별로 재생횟수를 sort()를 사용하여 정렬

- sort 메서드의 시간 복잡도는 O(klogk) (K는 장르의 개수)

3. 각 장르에서 노래 선택하여 answer에 push

- 이중 for문을 사용하긴 하지만,
- 바깥쪽 for문은 장르의 개수에 영향을 받고, 내부 for문은 배열의 길이가 최대 2이다.

따라서 전체 시간복잡도는 O(N) + O(KlogK)이고, 주어진 문제에 의하면 N은 최대 10,000이고, k는 최대 99임
