---
title: 'tensorflow 패키지 버전 충돌로 인한 에러 해결 과정'
date: '2024-02-24'
category: 'trouble-shooting'
summary: '패키지 버전 충돌을 찾아내고 해결한 기록 ..'
pinned: true
---

## 에러 발생 및 원인 찾기

스크래치 확장 기능 중, `객체 인식하기` 기능이 동작하지 않는 버그가 발생했다. 자주 사용되는 기능이 아니어서 버그 리포팅이 늦게 되었다. 언제부터 해당 기능이 동작하지 않았는지 확인이 필요했고, 의심이 가는 풀리퀘스트들을 몇개 추려내어, 전후 시점으로 롤백을 해보며 에러 발생 시기를 추적하였다.

확인해본 결과, `티처블 머신 모델 학습하기` 기능을 추가한 이후, 기존 인식 서비스의 `객체 인식하기` 기능이 작동하지 않는 것이었다. 두 기능 모두 텐서플로우 패키지를 사용하는 라이브러리였다.

하지만 `티처블 머신 모델 학습하기` 기능은 scratch-gui라는 레포지토리에서 구현되어있고, `객체 인식하기` 기능은 scratch-gui가 사용하는 패키지같은 scratch-vm에서 구현된 기능이었기 때문에 해당 에러를 원인을 찾는데에 어려움이 있었다.

같은 tensorflow 패키지를 사용한다는 점에서 “버전 충돌때문일 것이다”라는 가정을 했지만, 각각의 기능이 구현된 repository가 다른데 왜 충돌하는지 알 수 없었고, `객체 인식하기` 기능 에러가 개발 환경에서는 재현되지 않고, 배포된 production 환경에서만 재현되었기 때문이다.

## 원인 찾기

우선 왜 이런 환경에 따라 에러가 다른 현상이 일어나는지에 대해 알아내는 것이 중요했다. scratch 프로젝트는 scratch-vm, scratch-l10n, scratch-blocks 등을 각각 개발하되, scratch-gui라는 core 레포지토리에서 나머지의 레포지토리를 패키지 형태로 사용하고 있다. 참고) https://jiwonyyy.site/posts/scratch-project

개발 환경에서는 개발의 편의성을 위해 **`npm link`**를 사용하여, 로컬에서 개발 중인 패키지를 다른 로컬 프로젝트에 연결하여 사용하고 있었다. 이 차이로 인해, 개발 환경에서는 scratch-vm, l10n, blocks등이 각각의 package-lock.json을 갖고 있었고, 배포 환경에서는 그렇지 않았다. 따라서 “버전 충돌때문일 것이다”라는 가정을 검증할 수 있었고, 버전 충돌을 해결하기 위한 방안을 생각하였다.

## 해결 방안 모색

3가지의 해결 방안을 고려해보게 되었다.

1. `티처블 머신 모델 학습 기능`이 독립적인 패키지 버전을 사용할 수 있게 하기
   1. 티처블 머신 모델 학습 기능을 따로 번들링 하여 배포한다.
   2. git submodule 을 사용하여 티처블 머신 모델을 gui 하위에서 별도 레포지토리로 관리한다.
2. 호환 가능한 버전을 찾아서 적용시킨다.
   1. 개발된 티처블 머신 기능의 버전을 높인다. → 추가적인 기능 개발 필요
   2. 기존의 개발 된 기능 두 가지 모두가 동작하는 버전을 찾는다. → 다양한 버전을 테스트하는데에 시간이 오래 걸림

4가지의 해결 방안 중에 어떤 것을 적용시킬 지 고민하다가, 우선은 해당 내용은 이미 배포된 내용이기 때문에 유저가 오픈되어있는 기능을 사용할 수 없는 시간을 최소화해야 했기 때문에 1-a번 방안으로 해결한 후, 2-a방법으로 티처블 머신 기능 자체도 개선하고, 버전 충돌도 해소하는 방식으로 진행하기로 결정하였다.

---

## 개발 과정

- 처음에 웹팩 번들링을 처음 설정해보는 과정에서, 기존 gui 내의 웹팩 설정을 사용하여 `tm-training.js` 를 번들링 하고 해당 파일을 사용했더니 gui를 번들링하는 과정에서 이미 번들링된 `tm-training.js` 이 또 한번 번들링이 되면서 코드가 원래대로 동작하지 않는 상황이 있었다.
- gui 하위 새로운 디렉토리에서 다시 webpack 프로젝트를 생성하여 번들링을 하고, 번들링된 javascript 파일을 사용하는 방식으로 구현하였다.

### 구현 단계

1. 기존에 src/lib 폴더 내에 구현 되었던 `TmTraining` class를 따로 번들링 하기 위해서 위해서 lib 폴더 내에 새로운 `tm-training` 디렉토리를 생성하고 프로젝트를 시작한다.
2. `tm-training` 에서 webpack 설치한다.
3. `티처블 머신 모델 학습` 기능을 위해 scratch-gui에 설치했던 패키지를 삭제하고, `tm-training` 디렉토리에 설치한다.
4. \*\* webpack config 설정한다.
   1. class를 import해서 instance를 만들어서 사용하였는데, 이러한 방식을 유지하기 위해서 같은 `TmTraining` 의 이름으로 모듈을 export 해주기 위해서 config에 추가 설정을 해주어야 한다.

      ```jsx
      const config = {
        entry: {
          'tm-training': './src/tm-training.js',
        },
        output: {
          library: {
            name: 'TmTraining',
            type: 'umd',
          },
          path: path.resolve(__dirname, 'dist'),
        },
        module: {
          rules: [
            // ... 기존 설정
          ],
        },
      };
      ```
   - entry에서는 { “빌드된 파일 명” : “빌드할 파일 경로” } 를 작성해준다.
   - output 설정이 중요했는데 library 프로퍼티에서
     { name : “import 해서 사용할 모듈 이름”, type: “umd” } 를 작성한다. - type: 'umd' 를 설정하면 \*\*\*\*모든 모듈 정의 아래에 라이브러리가 내보내진다.
5. tm-training 디렉토리에서 build를 하고, 해당 파일을 scratch-gui에서 TmTraining class를 import하는 부분에서 사용한다.

## 성장한 점

1. 에러의 원인을 정확히 파악하고, 여러 가능한 해결 방안 중에서 가장 효율적인 방법을 선택하여 적용했다. 이를 통해 문제 해결에 대한 접근 방식을 발전시켰다.
2. 개발 환경과 배포 환경에서 다르게 동작하는 문제를 직면했을 때, 문제를 식별하고 해결할 수 있었다.
3. 프로젝트 내부의 모듈을 Webpack을 사용하여 별도로 번들링하는 경험을 통해, 모듈 관리에 대한 이해도를 높였다.
